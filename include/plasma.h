/* Plasma Cache C API
 *
 * Thread-safe C API for integrating Plasma cache into external toolchains.
 *
 * ## Example Usage
 *
 * ```c
 * #include "plasma.h"
 * #include <stdio.h>
 *
 * int main() {
 *     // Initialize cache
 *     PlasmaCache *cache = plasma_cache_init("/tmp/plasma-cache");
 *     if (!cache) {
 *         fprintf(stderr, "Failed to initialize cache: %s\n", plasma_last_error());
 *         return 1;
 *     }
 *
 *     // Store artifact
 *     const char *data = "Hello, World!";
 *     const char *hash = "abc123def456";
 *     if (plasma_cache_put(cache, hash, (const uint8_t*)data, 13) != PLASMA_OK) {
 *         fprintf(stderr, "Failed to put: %s\n", plasma_last_error());
 *     }
 *
 *     // Check existence
 *     int exists = 0;
 *     if (plasma_cache_exists(cache, hash, &exists) == PLASMA_OK) {
 *         printf("Artifact exists: %d\n", exists);
 *     }
 *
 *     // Retrieve artifact
 *     uint8_t buffer[1024];
 *     size_t bytes_read = 0;
 *     if (plasma_cache_get(cache, hash, buffer, sizeof(buffer), &bytes_read) == PLASMA_OK) {
 *         printf("Retrieved %zu bytes\n", bytes_read);
 *     }
 *
 *     // Cleanup
 *     plasma_cache_free(cache);
 *     return 0;
 * }
 * ```
 *
 * ## Memory Management
 *
 * - All cache handles must be freed with `plasma_cache_free()`
 * - Error strings are owned by the library and should not be freed
 * - All functions are thread-safe
 *
 * ## Error Handling
 *
 * All functions return error codes. Use `plasma_last_error()` to get
 * the error message for the current thread.
 *
 * Copyright (c) 2025 Plasma
 * Licensed under MIT License
 */

#ifndef PLASMA_H
#define PLASMA_H

#pragma once

/* Generated with cbindgen:0.29.2 */

/* Warning: This file is auto-generated by cbindgen. Do not modify. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/*
 Result codes
 */
#define PlasmaPLASMA_OK 0

#define PlasmaPLASMA_ERROR -1

#define PlasmaPLASMA_ERROR_NOT_FOUND -2

#define PlasmaPLASMA_ERROR_INVALID_HASH -3

#define PlasmaPLASMA_ERROR_IO -4

/*
 Filesystem-based storage with RocksDB metadata tracking

 Layout:
 - `.plasma/cache/objects/ab/cd1234...` - Content-addressed blob storage (first 2 chars = subdir)
 - `.plasma/cache/metadata/` - RocksDB database for access tracking and eviction

 Optimizations:
 - RocksDB provides concurrent reads/writes out of the box
 - Async batched access tracking (touch operations)
 - Snappy compression for metadata
 - Column families for efficient indexing (LRU/LFU eviction)
 - Automatic eviction when cache exceeds max_size
 */
typedef struct PlasmaFilesystemStorage PlasmaFilesystemStorage;

/*
 Opaque handle to a Plasma cache instance
 */
typedef struct PlasmaPlasmaCache {
    struct PlasmaFilesystemStorage storage;
} PlasmaPlasmaCache;

/*
 Initialize a new Plasma cache instance

 # Arguments
 * `cache_dir` - Path to cache directory (NULL-terminated C string)

 # Returns
 * Pointer to PlasmaCache on success
 * NULL on error (use `plasma_last_error()` to get error message)

 # Safety
 * `cache_dir` must be a valid NULL-terminated C string
 * Returned pointer must be freed with `plasma_cache_free()`
 */
plasma_ struct PlasmaPlasmaCache *plasma_cache_init(const char *aCacheDir);

/*
 Initialize a new Plasma cache instance with custom eviction settings

 # Arguments
 * `cache_dir` - Path to cache directory (NULL-terminated C string)
 * `max_size_bytes` - Maximum cache size in bytes (0 for default: 5GB)
 * `eviction_policy` - Eviction policy: 0=LRU, 1=LFU, 2=TTL (default: LFU)
 * `ttl_seconds` - Default TTL in seconds (0 for default: 7 days)

 # Returns
 * Pointer to PlasmaCache on success
 * NULL on error (use `plasma_last_error()` to get error message)

 # Safety
 * `cache_dir` must be a valid NULL-terminated C string
 * Returned pointer must be freed with `plasma_cache_free()`
 */
plasma_
struct PlasmaPlasmaCache *plasma_cache_init_with_eviction(const char *aCacheDir,
                                                          uint64_t aMaxSizeBytes,
                                                          int aEvictionPolicy,
                                                          uint64_t aTtlSeconds);

/*
 Free a Plasma cache instance

 # Safety
 * `cache` must be a valid pointer returned by `plasma_cache_init()`
 * Must not be used after calling this function
 */
plasma_ void plasma_cache_free(struct PlasmaPlasmaCache *aCache);

/*
 Get an artifact from the cache

 # Arguments
 * `cache` - Cache instance
 * `hash` - Content hash (NULL-terminated C string)
 * `output_buffer` - Buffer to write data (must be pre-allocated)
 * `buffer_size` - Size of output buffer
 * `bytes_written` - Output: actual bytes written

 # Returns
 * `PLASMA_OK` on success
 * `PLASMA_ERROR_NOT_FOUND` if artifact not found
 * `PLASMA_ERROR` on other errors

 # Safety
 * All pointers must be valid
 * `output_buffer` must have at least `buffer_size` bytes allocated
 */
plasma_
int plasma_cache_get(struct PlasmaPlasmaCache *aCache,
                     const char *aHash,
                     uint8_t *aOutputBuffer,
                     uintptr_t aBufferSize,
                     uintptr_t *aBytesWritten);

/*
 Put an artifact into the cache

 # Arguments
 * `cache` - Cache instance
 * `hash` - Content hash (NULL-terminated C string)
 * `data` - Data to store
 * `data_len` - Length of data in bytes

 # Returns
 * `PLASMA_OK` on success
 * `PLASMA_ERROR` on error

 # Safety
 * All pointers must be valid
 * `data` must have at least `data_len` bytes
 */
plasma_
int plasma_cache_put(struct PlasmaPlasmaCache *aCache,
                     const char *aHash,
                     const uint8_t *aData,
                     uintptr_t aDataLen);

/*
 Check if an artifact exists in the cache

 # Arguments
 * `cache` - Cache instance
 * `hash` - Content hash (NULL-terminated C string)
 * `exists` - Output: 1 if exists, 0 if not

 # Returns
 * `PLASMA_OK` on success
 * `PLASMA_ERROR` on error

 # Safety
 * All pointers must be valid
 */
plasma_ int plasma_cache_exists(struct PlasmaPlasmaCache *aCache, const char *aHash, int *aExists);

/*
 Delete an artifact from the cache

 # Arguments
 * `cache` - Cache instance
 * `hash` - Content hash (NULL-terminated C string)

 # Returns
 * `PLASMA_OK` on success
 * `PLASMA_ERROR` on error

 # Safety
 * All pointers must be valid
 */
plasma_ int plasma_cache_delete(struct PlasmaPlasmaCache *aCache, const char *aHash);

/*
 Get the last error message

 # Returns
 * Pointer to NULL-terminated error string
 * NULL if no error

 # Safety
 * Returned string is valid until next API call
 * Do not free the returned pointer
 */
plasma_ const char *plasma_last_error(void);

/*
 Free a string allocated by the Plasma library

 # Safety
 * `s` must be a string allocated by a Plasma API function
 */
plasma_ void plasma_free_string(char *aS);

/*
 Get the library version

 # Returns
 * Pointer to NULL-terminated version string

 # Safety
 * Returned string is statically allocated, do not free
 */
plasma_ const char *plasma_version(void);

#endif  /* PLASMA_H */
